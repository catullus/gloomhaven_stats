{
    "collab_server" : "",
    "contents" : "## 3. simulation logic\nsim_mindthief <- function(modifier_deck, attack_deck = c(2,2), augment, ally=0, ally_attack = c(2, 2)){\n    ## realistically, this only simulates the first hit on a creature plus a follow-up hit if there is an ally adjacent and attacking the same creature (ally = 1)\n    ## 1. draw a random modifier card\n    ## 2. add augment to this, if possible\n    ## 3. estimate damage output\n    ## 3b. if ally == 1, add base +2 attack PLUS anything from debuff e.g. poison, wound\n    ## 4. store total damage output and debuff\n    \n    ### 1. draw a random card, parse it into a number or result...if miss, then damage = 0, if 2x, then double damage\n    output = list()\n    card = sample(x = modifier_deck, size = 1)\n    card_check = as.integer(card)\n    \n    ##> branch A1 = card is a string\n    if (is.na(card_check)){\n        ##>> branch B1a = is ally attacking creature too?\n        if (ally == 1){\n            if (card == \"2x\"){\n                ## DOUBLE\n                damage = (2 * ((sample(x = attack_deck, size = 1) + augment$attack))) + \n                    sample(x = ally_attack, size = 1) + \n                    ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0)\n                \n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            } else if (card == \"miss\"){\n                ## MISS\n                damage = 0\n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            }\n            ##>> branch B1b\n        } else if (ally == 0){\n            if (card == \"2x\"){\n                ## DOUBLE\n                ## if no ally, spread poison damage out over 2 rounds since I haven't tracked state yet\n                damage = (2 * ((sample(x = attack_deck, size = 1) + augment$attack))) + \n                    ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 0.5, 0)\n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            } else if (card == \"miss\"){\n                ## MISS\n                damage = 0\n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            }\n        } else if (ally == 2){\n            if (card == \"2x\"){\n                ## DOUBLE\n                damage = (2 * ((sample(x = attack_deck, size = 1) + augment$attack))) + \n                    sample(x = ally_attack, size = 1) + \n                    ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0) + \n                    ## second ally attack\n                    sample(x = ally_attack, size = 1) + \n                    ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0)\n                \n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            } else if (card == \"miss\"){\n                ## MISS\n                damage = 0\n                #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n                return(damage)\n            }\n        }\n        \n    ##> branch A2 = card is an integer   \n    } else if (!is.na(card_check)){\n        ##>> branch B2a = if ally is attacking same creature\n        if (ally == 1){\n        damage = as.integer(card) + \n            sample(x = attack_deck, size = 1) + \n            augment$attack + \n            sample(x = ally_attack, size = 1) + \n            ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0) \n        \n        #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n        return(damage)\n        ##>> branch B2b\n        } else if (ally == 0){\n            ## if no ally, spread poison damage out over 2 rounds since I haven't tracked state yet\n            damage = as.integer(card) + \n                sample(x = attack_deck, size = 1) + \n                augment$attack + \n                ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 0.5, 0) \n            \n            #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n            return(damage)\n        } else if (ally == 2){\n            damage = as.integer(card) + \n                sample(x = attack_deck, size = 1) + \n                augment$attack + \n                sample(x = ally_attack, size = 1) + \n                ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0) +    \n                ## second ally attack\n                sample(x = ally_attack, size = 1) + \n                ifelse(grepl(x = augment$debuff, pattern = \"poison\"), 1, 0) \n            \n            #print(paste(damage, \"ally=\", ally, \"ally_attack=\", ally_attack, \"aug_debuff =\",augment$debuff, \"aug_attack=\", augment$attack))\n            return(damage)\n        }\n    } ## branch B2\n    \n} # function closer\n\n\n### test numeric cards\n#sim_mindthief(modifier_deck = base_modifier_deck, augment = mt_augments[[1]], ally = 1)\n\n### test string cards\n#sim_mindthief(modifier_deck = \"miss\", augment = mt_augments[[1]], ally = 1)\n\n",
    "created" : 1526917523059.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3301578143",
    "id" : "291D257E",
    "lastKnownWriteTime" : 1526917537,
    "last_content_update" : 1526917537410,
    "path" : "~/Documents/GitHub/gloomhaven_stats/function_mindthief.R",
    "project_path" : "function_mindthief.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}